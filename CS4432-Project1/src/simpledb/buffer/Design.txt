Changes were made to the Buffer and BasicBufferMgr (referred to as BBM) classes; no new classes were introduced aside from our SQL tests. One minor change was made to
BufferMgr in order to implement replacement policy choices.

REPLACEMENT POLICIES:
Several new values were added to the Buffer class to keep track of last access time and the "ref" flag. Getters and setters were generated accordingly.

In order to determine which replacement policy to use, the program is now capable of taking in a second input on server startup, an int flag. This
flag determines whether to use LRU (2), clock (3), or the default included with simbleDB (any other value - uses default if no flag given). This flag is passed
into a new value of the BBM class for this process. The replacement policy to use is chosen based on this flag whenever a new buffer needs to be added to the pool
and the pool is already full.

LRU
Whenever a buffer is accessed (pinned, unpinned, or otherwise updated), the access time of the buffer is updated to the current system time in nanoseconds. 
When replacement must occur, the buffer manager increments through the buffer pool, checking pin status and access time of each frame. It navigates through the entire
pool, keeping track of the oldest access time, and when this process is complete, the buffer manager replaces the frame at the position with the oldest access time.

CLOCK
BBM also holds a new int value to store the current position for clock replacement. Our clock policy implementation makes one key assumption. If the buffer is empty, 
ClockPolicy isn't called and the clock pointer will not move until actual eviction is needed, and it will start at 0th position until then. The method implemented issues
a recursive call at each position until a candidate is found. If the current frame is pinned, it is skipped. If the current frame is unpinned and its ref value is 1, set ref
to 0 and skip it. A viable candidate is a buffer that is unpinned and its ref flag equals 0. The buffer manager then replaces this buffer with the new one.


EFFICIENCY IMPROVEMENTS:
SEARCH FOR GIVEN FRAME
To implement this feature, we added a hashmap into the buffer manager which stores a hashed block ID as the key and the block position as its value. More additions were
made to Buffer to accommodate this; buffers now store an int value indicating their position in a buffer pool, and there is now a getter method for the block within the buffer.
A getter and setter pair were generated for the position value so that whenever a buffer is added to the pool, its position is stored. At the same time (as well as when a buffer
is updated), the hashed block ID and block position pair are stored in the hashmap. The default findExistingBuffer() function was overhauled; it now searches the hashmap for the
given block's hashed block ID, returning its position if found (null otherwise).

SEARCH FOR EMPTY FRAME
To implement this feature, we added a list of integers to the BBM. This list is initially populated with the entire empty buffer pool. Whenever the buffer manager checks
for an available frame in the pool, it first checks the frame at the first position of this list. If this position is valid, it will put the new buffer here and remove
this frame from the list. If the list is empty, the buffer is full, and as such, it will not be repopulated; replacement policies will take effect instead.


PINNING AND DIRTY FRAMES
While these features were requested in the assignment, they have already been implemented adequately in simpleDB exactly as requested. No changes were made.